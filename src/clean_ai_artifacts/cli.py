"""
clean-ai-artifacts: Remove AI-generated markdown files and emojis from codebases.
"""

import argparse
import os
import sys
from pathlib import Path

try:
    import emoji
except ImportError:
    emoji = None


IGNORE_DIRS = frozenset({
    "node_modules", ".git", ".svn", ".hg", ".idea", ".vscode",
    "__pycache__", "venv", "env", ".env", "dist", "build", "target",
    "vendor", "bin", "obj", ".tox", ".nox", ".pytest_cache",
    ".mypy_cache", ".ruff_cache", "site-packages", ".cargo",
})


IGNORE_FILES = frozenset({
    "README.md", "readme.md", "LICENSE", "license", "CHANGELOG.md", "changelog.md"
})


BINARY_EXTENSIONS = frozenset({
    ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp", ".bmp", ".tiff",
    ".exe", ".dll", ".so", ".dylib", ".bin", ".o", ".a",
    ".pyc", ".pyo", ".pyd", ".class", ".jar", ".war",
    ".zip", ".tar", ".gz", ".7z", ".rar", ".bz2", ".xz",
    ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
    ".db", ".sqlite", ".sqlite3", ".parquet", ".pickle", ".pkl",
    ".woff", ".woff2", ".ttf", ".otf", ".eot",
    ".mp3", ".mp4", ".wav", ".avi", ".mov", ".mkv", ".flac",
    ".lock",
})

DEFAULT_AI_MARKERS = [
    "Generated by AI",
    "# AI Generated",
    "This file was automatically generated",
]

DEFAULT_AI_SUFFIX = "_ai.md"


def is_binary_file(path: Path) -> bool:
    try:
        with open(path, "rb") as f:
            chunk = f.read(8192)
            return b"\x00" in chunk
    except (OSError, IOError):
        return True


def is_ai_generated(path: Path, markers: list[str], suffix: str) -> bool:
    if path.name.endswith(suffix):
        return True
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            header = f.read(1024)
            return any(marker in header for marker in markers)
    except (OSError, IOError):
        return False


def remove_emojis(content: str) -> str:
    if emoji is None:
        import re
        emoji_pattern = re.compile(
            "["
            "\U0001F600-\U0001F64F"
            "\U0001F300-\U0001F5FF"
            "\U0001F680-\U0001F6FF"
            "\U0001F1E0-\U0001F1FF"
            "\U00002702-\U000027B0"
            "\U000024C2-\U0001F251"
            "]+",
            flags=re.UNICODE,
        )
        return emoji_pattern.sub("", content)
    return emoji.replace_emoji(content, replace="")


def clean_directory(
    root_path: Path,
    dry_run: bool = False,
    clean_emojis: bool = True,
    clean_md: bool = True,
    ai_markers: list[str] | None = None,
    ai_suffix: str = DEFAULT_AI_SUFFIX,
    verbose: bool = True,
) -> dict:
    if ai_markers is None:
        ai_markers = DEFAULT_AI_MARKERS

    stats = {"deleted_files": 0, "cleaned_files": 0, "errors": 0}
    script_path = Path(__file__).resolve()

    for dirpath, dirnames, filenames in os.walk(root_path):
        dirnames[:] = [d for d in dirnames if d not in IGNORE_DIRS]

        for filename in filenames:
            if filename in IGNORE_FILES:
                continue

            filepath = Path(dirpath) / filename

            if filepath.resolve() == script_path:
                continue

            if filepath.suffix.lower() in BINARY_EXTENSIONS:
                continue

            # Task 1: Remove AI MD
            if clean_md and filepath.suffix == ".md":
                if is_ai_generated(filepath, ai_markers, ai_suffix):
                    if verbose:
                        action = "[DRY-RUN] Would delete" if dry_run else "[DELETED]"
                        print(f"{action}: {filepath.relative_to(root_path)}")
                    if not dry_run:
                        try:
                            filepath.unlink()
                            stats["deleted_files"] += 1
                        except OSError as e:
                            print(f"[ERROR] Could not delete {filepath}: {e}", file=sys.stderr)
                            stats["errors"] += 1
                    else:
                        stats["deleted_files"] += 1
                    continue

            # Task 2: Remove Emojis
            if clean_emojis:
                if is_binary_file(filepath):
                    continue

                try:
                    with open(filepath, "r", encoding="utf-8") as f:
                        content = f.read()

                    cleaned = remove_emojis(content)

                    if content != cleaned:
                        if verbose:
                            action = "[DRY-RUN] Would clean" if dry_run else "[CLEANED]"
                            print(f"{action}: {filepath.relative_to(root_path)}")
                        if not dry_run:
                            with open(filepath, "w", encoding="utf-8") as f:
                                f.write(cleaned)
                        stats["cleaned_files"] += 1

                except UnicodeDecodeError:
                    pass
                except OSError as e:
                    print(f"[ERROR] Could not process {filepath}: {e}", file=sys.stderr)
                    stats["errors"] += 1

    return stats


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        prog="clean-ai-artifacts",
        description="Remove AI-generated markdown files and emojis from your codebase.",
    )
    parser.add_argument("path", nargs="?", default=".", help="Directory to clean")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be changed")
    parser.add_argument("--no-emoji", action="store_true", help="Skip emoji removal")
    parser.add_argument("--no-md", action="store_true", help="Skip AI markdown removal")
    parser.add_argument("--quiet", "-q", action="store_true", help="Suppress output")
    parser.add_argument("--ai-suffix", default=DEFAULT_AI_SUFFIX, help="Suffix pattern")
    parser.add_argument("--version", "-v", action="version", version="%(prog)s 1.0.0")

    args = parser.parse_args(argv)
    root = Path(args.path).resolve()
    
    if not root.is_dir():
        print(f"Error: '{args.path}' is not a directory", file=sys.stderr)
        return 1

    if not args.quiet:
        mode = "[DRY-RUN] " if args.dry_run else ""
        print(f"{mode}Scanning: {root}\n")

    stats = clean_directory(
        root_path=root,
        dry_run=args.dry_run,
        clean_emojis=not args.no_emoji,
        clean_md=not args.no_md,
        ai_suffix=args.ai_suffix,
        verbose=not args.quiet,
    )

    if not args.quiet:
        print(f"\nSummary: {stats['deleted_files']} files deleted, {stats['cleaned_files']} files cleaned")

    return 1 if stats["errors"] else 0

if __name__ == "__main__":
    sys.exit(main())
