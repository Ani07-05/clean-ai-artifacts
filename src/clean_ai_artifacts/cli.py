"""
clean-ai-artifacts: Remove AI-generated markdown files and emojis from codebases.
"""

import argparse
import os
import sys
from pathlib import Path


try:
    import emoji
    from packaging import version
    EMOJI_MIN_VERSION = "2.0.0"
    if hasattr(emoji, "__version__") and version.parse(emoji.__version__) < version.parse(EMOJI_MIN_VERSION):
        print(f"[WARNING] emoji library version {emoji.__version__} is outdated. Some emojis may not be removed. Please upgrade to >= {EMOJI_MIN_VERSION}.", file=sys.stderr)
except ImportError:
    emoji = None

# Folders to skip
IGNORE_DIRS = frozenset({
    "node_modules", ".git", ".svn", ".hg", ".idea", ".vscode",
    "__pycache__", "venv", "env", ".env", "dist", "build", "target",
    "vendor", "bin", "obj", ".tox", ".nox", ".pytest_cache",
    ".mypy_cache", ".ruff_cache", "site-packages", ".cargo",
})

# Files to NEVER delete (Safety List)
IGNORE_FILES = frozenset({
    "README.md", "readme.md", "LICENSE", "license", "CHANGELOG.md", "changelog.md"
})

# Binary extensions to skip
BINARY_EXTENSIONS = frozenset({
    ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp", ".bmp", ".tiff",
    ".exe", ".dll", ".so", ".dylib", ".bin", ".o", ".a",
    ".pyc", ".pyo", ".pyd", ".class", ".jar", ".war",
    ".zip", ".tar", ".gz", ".7z", ".rar", ".bz2", ".xz",
    ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
    ".db", ".sqlite", ".sqlite3", ".parquet", ".pickle", ".pkl",
    ".woff", ".woff2", ".ttf", ".otf", ".eot",
    ".mp3", ".mp4", ".wav", ".avi", ".mov", ".mkv", ".flac",
    ".lock",
})

DEFAULT_AI_MARKERS = [
    "Generated by AI",
    "",
    "# AI Generated",
    "This file was automatically generated",
]

DEFAULT_AI_SUFFIX = "_ai.md"


def is_binary_file(path: Path) -> bool:
    try:
        with open(path, "rb") as f:
            chunk = f.read(8192)
            return b"\x00" in chunk
    except (OSError, IOError):
        return True


def is_ai_generated(path: Path, markers: list[str], suffix: str) -> bool:
    if path.name.endswith(suffix):
        return True
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            header = f.read(1024)
            return any(marker in header for marker in markers)
    except (OSError, IOError):
        return False


def remove_emojis(content: str, emoji_pattern_override=None, emoji_exclude=None) -> str:
    """
    Remove emojis from content.
    :param content: The text to clean.
    :param emoji_pattern_override: Optional regex pattern (compiled) to use instead of the default.
    :param emoji_exclude: Optional set/list of emoji to exclude from removal.
    """
    if emoji_exclude:
        # Remove only emojis not in the exclude list
        def _remove(match):
            return match.group(0) if match.group(0) in emoji_exclude else ""
    else:
        def _remove(match):
            return ""

    if emoji is None:
        import re
        pattern = emoji_pattern_override
        if pattern is None:
            # ...existing code for default regex...
            pattern = re.compile(
                r"("  # Start group
                r"[\U0001F1E6-\U0001F1FF]{2}"  # flags (iOS)
                r"|[\U0001F600-\U0001F64F]"  # emoticons
                r"|[\U0001F300-\U0001F5FF]"  # symbols & pictographs
                r"|[\U0001F680-\U0001F6FF]"  # transport & map
                r"|[\U0001F700-\U0001F77F]"  # alchemical symbols
                r"|[\U0001F780-\U0001F7FF]"  # Geometric Shapes Extended
                r"|[\U0001F800-\U0001F8FF]"  # Supplemental Arrows-C
                r"|[\U0001F900-\U0001F9FF]"  # Supplemental Symbols and Pictographs
                r"|[\U0001FA00-\U0001FA6F]"  # Chess Symbols, Symbols and Pictographs Extended-A
                r"|[\U0001FA70-\U0001FAFF]"  # Symbols and Pictographs Extended-A
                r"|[\U00002702-\U000027B0]"  # Dingbats
                r"|[\U000024C2-\U0001F251]"  # Enclosed characters
                r"|[\U0001F926-\U0001F937]"  # Supplemental symbols
                r"|[\U0001F1E6-\U0001F1FF]"  # flags
                r"|[\U0001F191-\U0001F251]"  # squares
                r"|[\U0001F004-\U0001F0CF]"  # Mahjong, playing cards
                r"|[\U0001F170-\U0001F171]"  # enclosed letters
                r"|[\U0001F17E-\U0001F17F]"
                r"|[\U0001F18E]"
                r"|[\U0001F191-\U0001F19A]"
                r"|[\U0001F1E6-\U0001F1FF]"  # regional indicator symbols
                r"|[\U0001F201-\U0001F202]"
                r"|[\U0001F21A]"
                r"|[\U0001F22F]"
                r"|[\U0001F232-\U0001F23A]"
                r"|[\U0001F250-\U0001F251]"
                r"|[\U0001F300-\U0001F320]"
                r"|[\U0001F32D-\U0001F335]"
                r"|[\U0001F337-\U0001F37C]"
                r"|[\U0001F37E-\U0001F393]"
                r"|[\U0001F3A0-\U0001F3CA]"
                r"|[\U0001F3CF-\U0001F3D3]"
                r"|[\U0001F3E0-\U0001F3F0]"
                r"|[\U0001F3F4]"
                r"|[\U0001F3F8-\U0001F43E]"
                r"|[\U0001F440]"
                r"|[\U0001F442-\U0001F4FC]"
                r"|[\U0001F4FF-\U0001F53D]"
                r"|[\U0001F54B-\U0001F54E]"
                r"|[\U0001F550-\U0001F567]"
                r"|[\U0001F57A]"
                r"|[\U0001F595-\U0001F596]"
                r"|[\U0001F5A4]"
                r"|[\U0001F5FB-\U0001F64F]"
                r"|[\U0001F680-\U0001F6C5]"
                r"|[\U0001F6CC]"
                r"|[\U0001F6D0-\U0001F6D2]"
                r"|[\U0001F6EB-\U0001F6EC]"
                r"|[\U0001F6F0-\U0001F6F3]"
                r"|[\U0001F910-\U0001F93A]"
                r"|[\U0001F93C-\U0001F93E]"
                r"|[\U0001F940-\U0001F945]"
                r"|[\U0001F947-\U0001F94C]"
                r"|[\U0001F950-\U0001F96B]"
                r"|[\U0001F980-\U0001F997]"
                r"|[\U0001F9C0]"
                r"|[\U0001F9D0-\U0001F9E6]"
                r"|[\u200d]"  # zero-width joiner
                r"|[\u2640-\u2642]"  # gender
                r"|[\u2600-\u2B55]"  # misc symbols
                r"|[\u23cf]"
                r"|[\u23e9-\u23f3]"
                r"|[\u23f8-\u23fa]"
                r")+",
                flags=re.UNICODE,
            )
        return pattern.sub(_remove, content)
    return emoji.replace_emoji(content, replace="", pattern=emoji_pattern_override) if emoji_pattern_override else emoji.replace_emoji(content, replace="")


def clean_directory(
    root_path: Path,
    dry_run: bool = False,
    clean_emojis: bool = True,
    clean_md: bool = True,
    ai_markers: list[str] | None = None,
    ai_suffix: str = DEFAULT_AI_SUFFIX,
    verbose: bool = True,
) -> dict:
    if ai_markers is None:
        ai_markers = DEFAULT_AI_MARKERS

    stats = {"deleted_files": 0, "cleaned_files": 0, "errors": 0}
    script_path = Path(__file__).resolve()

    for dirpath, dirnames, filenames in os.walk(root_path):
        dirnames[:] = [d for d in dirnames if d not in IGNORE_DIRS]

        for filename in filenames:
            if filename in IGNORE_FILES:
                continue

            filepath = Path(dirpath) / filename

            if filepath.resolve() == script_path:
                continue

            if filepath.suffix.lower() in BINARY_EXTENSIONS:
                continue

            # Task 1: Remove AI MD
            if clean_md and filepath.suffix == ".md":
                if is_ai_generated(filepath, ai_markers, ai_suffix):
                    if verbose:
                        action = "[DRY-RUN] Would delete" if dry_run else "[DELETED]"
                        print(f"{action}: {filepath.relative_to(root_path)}")
                    if not dry_run:
                        try:
                            filepath.unlink()
                            stats["deleted_files"] += 1
                        except OSError as e:
                            print(f"[ERROR] Could not delete {filepath}: {e}", file=sys.stderr)
                            stats["errors"] += 1
                    else:
                        stats["deleted_files"] += 1
                    continue

            # Task 2: Remove Emojis
            if clean_emojis:
                if is_binary_file(filepath):
                    continue

                try:
                    with open(filepath, "r", encoding="utf-8") as f:
                        content = f.read()

                    cleaned = remove_emojis(content)

                    if content != cleaned:
                        if verbose:
                            action = "[DRY-RUN] Would clean" if dry_run else "[CLEANED]"
                            print(f"{action}: {filepath.relative_to(root_path)}")
                        if not dry_run:
                            with open(filepath, "w", encoding="utf-8") as f:
                                f.write(cleaned)
                        stats["cleaned_files"] += 1

                except UnicodeDecodeError:
                    pass
                except OSError as e:
                    print(f"[ERROR] Could not process {filepath}: {e}", file=sys.stderr)
                    stats["errors"] += 1

    return stats


def main(argv: list[str] | None = None) -> int:

    parser = argparse.ArgumentParser(
        prog="clean-ai-artifacts",
        description="Remove AI-generated markdown files and emojis from your codebase.",
    )
    parser.add_argument("path", nargs="?", default=".", help="Directory to clean")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be changed")
    parser.add_argument("--no-emoji", action="store_true", help="Skip emoji removal")
    parser.add_argument("--no-md", action="store_true", help="Skip AI markdown removal")
    parser.add_argument("--quiet", "-q", action="store_true", help="Suppress output")
    parser.add_argument("--ai-suffix", default=DEFAULT_AI_SUFFIX, help="Suffix pattern")
    parser.add_argument("--emoji-pattern", type=str, default=None, help="Custom regex pattern for emoji removal (Python raw string)")
    parser.add_argument("--emoji-exclude", type=str, default=None, help="Comma-separated list of emoji to exclude from removal")
    parser.add_argument("--version", "-v", action="version", version="%(prog)s 1.0.0")

    args = parser.parse_args(argv)
    root = Path(args.path).resolve()
    
    if not root.is_dir():
        print(f"Error: '{args.path}' is not a directory", file=sys.stderr)
        return 1

    if not args.quiet:
        mode = "[DRY-RUN] " if args.dry_run else ""
        print(f"{mode}Scanning: {root}\n")


    # Prepare custom emoji pattern/exclude
    emoji_pattern_override = None
    emoji_exclude = None
    if args.emoji_pattern:
        import re
        emoji_pattern_override = re.compile(args.emoji_pattern, flags=re.UNICODE)
    if args.emoji_exclude:
        emoji_exclude = set(e.strip() for e in args.emoji_exclude.split(",") if e.strip())

    def remove_emojis_with_options(content):
        return remove_emojis(content, emoji_pattern_override=emoji_pattern_override, emoji_exclude=emoji_exclude)

    stats = clean_directory(
        root_path=root,
        dry_run=args.dry_run,
        clean_emojis=not args.no_emoji,
        clean_md=not args.no_md,
        ai_suffix=args.ai_suffix,
        verbose=not args.quiet,
    )

    if not args.quiet:
        if args.dry_run:
            print(f"\nDry Run Summary: {stats['deleted_files']} files to delete, {stats['cleaned_files']} files to clean")
        else:
            print(f"\nSummary: {stats['deleted_files']} files deleted, {stats['cleaned_files']} files cleaned")

    return 1 if stats["errors"] else 0

if __name__ == "__main__":
    sys.exit(main())
